#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import logging

from typing import List, Tuple, Set
from pathlib import Path
from argparse import ArgumentParser, RawDescriptionHelpFormatter

from pixie import __version__
from pixie.magic import find_elfs
from pixie.utils import ColorfulTheme, Colors, read_line, to_pkgdep
from pixie.readelf import ReadELF, AggregatedLibraries
from pixie.contents import Contents, get_packages

# Default sections for searching libraries
DEFAULT_SECTIONS: List[str] = ['.rodata', '.data']
# Packages that don't have to be in PKGDEP
BASE_PACKAGES: Set[str] = {'glibc', 'gcc-runtime'}


class PScanException(Exception):
    """Error occurred during scan"""


def help_msg(version: str) -> str:
    help_msg = '''pixie(version {}) - dependency scanner for ELF executables'''
    return help_msg.format(version)


def find_so(
    file: Path,
    base: Path
) -> Tuple[AggregatedLibraries, AggregatedLibraries]:
    relative_path = file.relative_to(base)
    relative_path_str = f'[{Colors.GREEN}{relative_path}{Colors.RESET}]'
    dynamic_libs = ReadELF.read_dynamic(file)
    external_libs = AggregatedLibraries(dynamic_libs.get_external_libraries())
    logging.info(
        f'Found {len(external_libs)} linked external libraries ' +
        relative_path_str)
    section_libs_all = AggregatedLibraries([])
    for section in DEFAULT_SECTIONS:
        section_out = ReadELF.find_so(file, section)
        section_libs = AggregatedLibraries(
            section_out.get_external_libraries())
        section_libs_num = len(section_libs)
        if section_libs_num < 1:
            logging.info(
                f'No reference to external library in {section} ' +
                relative_path_str)
            continue
        section_libs_all += section_libs
        logging.info(
            f'Found {len(section_libs)} possible references to ' +
            f'external libraries {relative_path_str}')
    return (external_libs, section_libs_all)


def search(
    libs: AggregatedLibraries,
    ignorable: bool = True,
    interactive: bool = True
) -> Set[str]:
    libs_dict = libs.get_inner()
    ret: Set[str] = set()
    contents = Contents(libs)
    # TODO: Implement sover matching
    for soname in libs_dict.keys():
        pkgs = get_packages(contents.run_grep(soname))
        if (len(pkgs) < 1):
            msg = f'No package provides {soname}'
            if ignorable:
                logging.warning(msg)
                continue
            else:
                logging.error(msg)
                raise PScanException(msg)
        pkgs_list = list(pkgs)
        pkgs_list.sort()
        if (len(pkgs) > 1):
            logging.warning(
                f'Multiple packages offer {soname}:{Colors.RESET}\n' +
                ', '.join(pkgs_list))
            first = pkgs_list[0]
            if interactive:
                pkg = read_line(
                    'Please choose one package',
                    default=first,
                    verify=lambda name: name in pkgs_list)
                ret.add(pkg)
            else:
                ret.add(first)
        else:
            ret.add(pkgs_list[0])
    return ret


def main():
    sh = logging.StreamHandler()
    sh.setLevel(logging.DEBUG)
    sh.setFormatter(ColorfulTheme())
    logging.basicConfig(
        encoding='utf-8',
        handlers=[sh],
        level=logging.INFO)
    parser = ArgumentParser(
        prog='pscan',
        description=help_msg(__version__),
        formatter_class=RawDescriptionHelpFormatter)
    parser.add_argument('path')
    parser.add_argument('-p', '--to-pkgdep', action='store_true')
    parser.add_argument('-e', '--exclude-possible', action='store_true')
    args = parser.parse_args()
    target = Path(args.path)
    if not target.exists():
        logging.error('No such file or directory')
        exit(1)
    dyn = AggregatedLibraries([])
    pos = AggregatedLibraries([])
    for file in find_elfs(target):
        (dyn_libs, pos_libs) = find_so(file, target)
        dyn += dyn_libs
        pos += pos_libs
    if len(dyn) + len(pos) < 1:
        logging.info('Nothing matched, exiting...')
        if args.to_pkgdep:
            print('PKGDEP=""')
        exit(0)
    logging.info(
        f'Summary: {len(dyn)} libraries linked:{Colors.RESET}\n{str(dyn)}')
    logging.info(
        f'Summary: {len(pos)} possible references:{Colors.RESET}\n{str(pos)}')
    logging.info('Searching corresponding packages ...')
    required_pkgs = search(dyn).difference(BASE_PACKAGES)
    required_pkgs_list = list(required_pkgs)
    required_pkgs_list.sort()
    possible_pkgs = search(pos, ignorable=True) \
        .difference(required_pkgs) \
        .difference(BASE_PACKAGES)
    possible_pkgs_list = list(possible_pkgs)
    possible_pkgs_list.sort()
    logging.info(
        f'Direct dependencies:{Colors.RESET}\n' +
        ', '.join(required_pkgs_list))
    logging.info(
        f'Possible dependencies:{Colors.RESET}\n' +
        ', '.join(possible_pkgs_list))
    if args.to_pkgdep:
        logging.info('Generating PKGDEP ...')
        if args.exclude_possible:
            pkgs = required_pkgs
        else:
            pkgs = required_pkgs.union(possible_pkgs)
        print(to_pkgdep(pkgs))


if __name__ == '__main__':
    main()
